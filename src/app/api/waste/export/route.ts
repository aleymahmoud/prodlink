import { NextRequest, NextResponse } from 'next/server';
import { db, wasteEntries, products, lines, profiles, reasons, wasteApprovals, approvalLevels } from '@/shared/lib/db';
import { eq, desc, and, gte, lte, asc } from 'drizzle-orm';
import { auth } from '@/auth';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export async function GET(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const lineId = searchParams.get('line_id');
    const startDate = searchParams.get('start_date');
    const endDate = searchParams.get('end_date');
    const status = searchParams.get('status') || 'approved';

    // Build conditions
    const conditions = [];

    if (lineId) {
      conditions.push(eq(wasteEntries.lineId, lineId));
    }

    if (startDate) {
      conditions.push(gte(wasteEntries.createdAt, new Date(startDate)));
    }

    if (endDate) {
      const endDateTime = new Date(endDate);
      endDateTime.setHours(23, 59, 59, 999);
      conditions.push(lte(wasteEntries.createdAt, endDateTime));
    }

    if (status !== 'all') {
      conditions.push(eq(wasteEntries.approvalStatus, status as 'pending' | 'approved' | 'rejected'));
    }

    // Fetch waste entries
    const entries = await db
      .select({
        id: wasteEntries.id,
        quantity: wasteEntries.quantity,
        unitOfMeasure: wasteEntries.unitOfMeasure,
        batchNumber: wasteEntries.batchNumber,
        notes: wasteEntries.notes,
        approvalStatus: wasteEntries.approvalStatus,
        appApproved: wasteEntries.appApproved,
        formApproved: wasteEntries.formApproved,
        createdAt: wasteEntries.createdAt,
        product: {
          name: products.name,
          code: products.code,
        },
        line: {
          name: lines.name,
          code: lines.code,
        },
        profile: {
          fullName: profiles.fullName,
        },
        reason: {
          name: reasons.name,
        },
      })
      .from(wasteEntries)
      .leftJoin(products, eq(wasteEntries.productId, products.id))
      .leftJoin(lines, eq(wasteEntries.lineId, lines.id))
      .leftJoin(profiles, eq(wasteEntries.createdBy, profiles.id))
      .leftJoin(reasons, eq(wasteEntries.reasonId, reasons.id))
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(desc(wasteEntries.createdAt));

    // Get approval history for each entry
    const entryIds = entries.map(e => e.id);
    const approvals = entryIds.length > 0 ? await db
      .select({
        wasteEntryId: wasteApprovals.wasteEntryId,
        status: wasteApprovals.status,
        approvedBy: profiles.fullName,
        levelName: approvalLevels.name,
        levelOrder: approvalLevels.levelOrder,
        updatedAt: wasteApprovals.updatedAt,
      })
      .from(wasteApprovals)
      .leftJoin(profiles, eq(wasteApprovals.approvedBy, profiles.id))
      .leftJoin(approvalLevels, eq(wasteApprovals.approvalLevelId, approvalLevels.id))
      .orderBy(asc(approvalLevels.levelOrder)) : [];

    // Generate PDF
    const doc = new jsPDF();

    // Title
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Waste Report', 14, 22);

    // Subtitle with filters
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    const filterText = [];
    if (lineId) {
      const line = entries[0]?.line;
      if (line) filterText.push(`Line: ${line.name}`);
    }
    if (startDate) filterText.push(`From: ${startDate}`);
    if (endDate) filterText.push(`To: ${endDate}`);
    filterText.push(`Status: ${status}`);
    doc.text(filterText.join(' | '), 14, 30);

    // Generated date
    doc.setFontSize(8);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 36);
    doc.text(`Generated by: ${session.user.name || session.user.email}`, 14, 40);

    // Table data
    const tableData = entries.map((entry, index) => {
      const entryApprovals = approvals.filter(a => a.wasteEntryId === entry.id);
      const approverNames = entryApprovals
        .filter(a => a.status === 'approved' && a.approvedBy)
        .map(a => `${a.levelName}: ${a.approvedBy}`)
        .join('\n');

      return [
        (index + 1).toString(),
        entry.createdAt ? new Date(entry.createdAt).toLocaleDateString() : '-',
        entry.line?.name || '-',
        entry.product?.name || '-',
        `${Number(entry.quantity)} ${entry.unitOfMeasure}`,
        entry.reason?.name || '-',
        entry.profile?.fullName || '-',
        entry.approvalStatus?.toUpperCase() || '-',
        approverNames || '-',
      ];
    });

    // Add table
    autoTable(doc, {
      startY: 45,
      head: [['#', 'Date', 'Line', 'Product', 'Quantity', 'Reason', 'Recorded By', 'Status', 'Approvals']],
      body: tableData,
      theme: 'striped',
      headStyles: {
        fillColor: [79, 70, 229], // indigo-600
        fontSize: 8,
        fontStyle: 'bold',
      },
      bodyStyles: {
        fontSize: 7,
      },
      columnStyles: {
        0: { cellWidth: 8 },
        1: { cellWidth: 18 },
        2: { cellWidth: 20 },
        3: { cellWidth: 25 },
        4: { cellWidth: 18 },
        5: { cellWidth: 20 },
        6: { cellWidth: 22 },
        7: { cellWidth: 15 },
        8: { cellWidth: 35 },
      },
    });

    // Add signature lines at the bottom
    const finalY = (doc as jsPDF & { lastAutoTable?: { finalY: number } }).lastAutoTable?.finalY || 200;

    if (finalY < 250) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Signatures:', 14, finalY + 15);

      doc.setFont('helvetica', 'normal');
      doc.setFontSize(9);

      // Signature lines
      doc.text('Prepared by: _______________________', 14, finalY + 30);
      doc.text('Date: _______________', 14, finalY + 38);

      doc.text('Reviewed by: _______________________', 100, finalY + 30);
      doc.text('Date: _______________', 100, finalY + 38);

      doc.text('Approved by: _______________________', 14, finalY + 55);
      doc.text('Date: _______________', 14, finalY + 63);
    }

    // Summary
    const totalQuantity = entries.reduce((sum, e) => sum + Number(e.quantity), 0);
    doc.setFontSize(8);
    doc.text(`Total Entries: ${entries.length} | Total Quantity: ${totalQuantity.toFixed(2)}`, 14, 290);

    // Generate PDF buffer
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'));

    // Return PDF
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="waste-report-${new Date().toISOString().split('T')[0]}.pdf"`,
      },
    });
  } catch (error) {
    console.error('PDF export error:', error);
    return NextResponse.json({ error: 'Failed to generate PDF' }, { status: 500 });
  }
}
